# Earley Parser Implementation in Python

from collections import defaultdict

class EarleyState:
    def __init__(self, lhs, rhs, dot, start):
        self.lhs = lhs      # Left-hand side (non-terminal)
        self.rhs = rhs      # Right-hand side (list of symbols)
        self.dot = dot      # Position of dot
        self.start = start  # Start position in input

    def is_complete(self):
        return self.dot == len(self.rhs)

    def next_symbol(self):
        if not self.is_complete():
            return self.rhs[self.dot]
        return None

    def advance(self):
        return EarleyState(self.lhs, self.rhs, self.dot + 1, self.start)

    def __eq__(self, other):
        return (self.lhs, self.rhs, self.dot, self.start) == (other.lhs, other.rhs, other.dot, other.start)

    def __hash__(self):
        return hash((self.lhs, tuple(self.rhs), self.dot, self.start))

    def __repr__(self):
        before_dot = ' '.join(self.rhs[:self.dot])
        after_dot = ' '.join(self.rhs[self.dot:])
        return f"[{self.lhs} → {before_dot} • {after_dot}, {self.start}]"


class EarleyParser:
    def __init__(self, grammar, start_symbol):
        self.grammar = grammar
        self.start_symbol = start_symbol

    def parse(self, words):
        n = len(words)
        chart = [set() for _ in range(n + 1)]

        # Add initial state
        chart[0].add(EarleyState("γ", [self.start_symbol], 0, 0))  # augmented start rule

        # Process each position
        for i in range(n + 1):
            changed = True
            while changed:
                changed = False
                new_states = set()

                for state in chart[i]:
                    next_symbol = state.next_symbol()

                    # 1. Predictor
                    if next_symbol and next_symbol in self.grammar:
                        for prod in self.grammar[next_symbol]:
                            new_state = EarleyState(next_symbol, prod, 0, i)
                            if new_state not in chart[i]:
                                new_states.add(new_state)

                    # 2. Completer
                    elif state.is_complete():
                        for prev_state in chart[state.start]:
                            if prev_state.next_symbol() == state.lhs:
                                advanced = prev_state.advance()
                                if advanced not in chart[i]:
                                    new_states.add(advanced)

                    # 3. Scanner
                    elif next_symbol and i < n and next_symbol == words[i]:
                        chart[i + 1].add(state.advance())

                if new_states:
                    chart[i].update(new_states)
                    changed = True

        # Check if completed start symbol exists
        final_state = EarleyState("γ", [self.start_symbol], 1, 0)
        accepted = final_state in chart[n]

        # Output results
        print("\n--- Earley Parsing Chart ---")
        for i, states in enumerate(chart):
            print(f"Chart[{i}]:")
            for s in states:
                print(f"  {s}")

        print("\n✅ Input accepted!" if accepted else "\n❌ Input rejected!")

        return accepted


# Example Grammar (simple arithmetic expression grammar)
grammar = {
    "E": [["E", "+", "T"], ["T"]],
    "T": [["T", "*", "F"], ["F"]],
    "F": [["(", "E", ")"], ["id"]]
}

parser = EarleyParser(grammar, "E")

# Test examples
parser.parse(["id", "+", "id", "*", "id"])
parser.parse(["(", "id", "+", "id", ")", "*", "id"])
parser.parse(["id", "+", "*", "id"])
